<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live MD Demo (OpenMM → Babylon.js CPK Viewer)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #e6edf7; font-family: 'Courier New', monospace; }
    #viewer { width: 100%; height: 100%; touch-action: none; display: block; outline: none; }
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border: 2px solid rgba(0, 255, 0, 0.5);
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.6;
      pointer-events: none;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
      display: none;
    }
    #hud-line { color: #0f0; }
    #play-pause {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      border: 2px solid rgba(0, 255, 0, 0.5);
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
      display: none;
    }
    #play-pause:hover { background: rgba(0, 50, 0, 0.9); }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1000;
    }
    #crosshair::before, #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(0, 255, 0, 0.6);
    }
    #crosshair::before {
      width: 20px;
      height: 2px;
      left: -10px;
      top: -1px;
    }
    #crosshair::after {
      width: 2px;
      height: 20px;
      left: -1px;
      top: -10px;
    }
    #atom-hud {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border: 2px solid rgba(0, 255, 0, 0.5);
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.6;
      pointer-events: none;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
      display: none;
      color: #0f0;
    }
  </style>
  <!-- Babylon.js from CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <canvas id="viewer" tabindex="1"></canvas>
  <div id="hud">
    <div id="hud-line">STATUS: <span id="status">LOADING...</span></div>
    <div id="hud-line">FRAME: <span id="frame-info">0/0</span></div>
    <div id="hud-line">ATOMS: <span id="atom-count">0</span></div>
  </div>
  <button id="play-pause">⏸ PAUSE</button>
  <div id="crosshair"></div>
  <div id="atom-hud">
    <div>ATOM: <span id="atom-element">-</span></div>
    <div>RESIDUE: <span id="atom-residue">-</span></div>
  </div>
  <script type="module">
    const statusEl = document.getElementById('status')
    const frameInfoEl = document.getElementById('frame-info')
    const atomCountEl = document.getElementById('atom-count')
    const playPauseBtn = document.getElementById('play-pause')
    const hudEl = document.getElementById('hud')
    const atomHudEl = document.getElementById('atom-hud')
    const atomElementEl = document.getElementById('atom-element')
    const atomResidueEl = document.getElementById('atom-residue')

    let pollTimer = null
    let currentBytes = 0
    let playing = true
    const pollIntervalSeconds = 5
    let hudVisible = false
    let currentFrame = 0
    let frames = []
    let atoms = []
    let atomSpheres = []

    // CPK colors (RGB 0-1)
    const CPK_COLORS = {
      'H': [1.0, 1.0, 1.0],    // white
      'C': [0.5, 0.5, 0.5],    // gray
      'N': [0.2, 0.2, 1.0],    // blue
      'O': [1.0, 0.2, 0.2],    // red
      'S': [1.0, 1.0, 0.0],    // yellow
      'P': [1.0, 0.5, 0.0],    // orange
    }

    // CPK radii in angstroms
    const CPK_RADII = {
      'H': 0.25, 'C': 0.7, 'N': 0.65, 'O': 0.6, 'S': 1.0, 'P': 1.0
    }

    // Babylon.js setup
    const canvas = document.getElementById('viewer')
    const engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: true,
      stencil: true,
      disableWebGL2Support: false
    })

    // Force canvas to native resolution regardless of CSS zoom
    engine.setHardwareScalingLevel(1 / window.devicePixelRatio)

    const scene = new BABYLON.Scene(engine)
    scene.clearColor = new BABYLON.Color3(0.043, 0.071, 0.125)

    const camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 0, -30), scene)
    camera.attachControl(canvas, true)
    camera.speed = 0.5
    camera.angularSensibility = 2000

    // Pointer lock for Minecraft-style mouse look (click to enable)
    canvas.addEventListener('click', () => {
      if (canvas.requestPointerLock) {
        canvas.requestPointerLock()
      } else if (canvas.mozRequestPointerLock) {
        canvas.mozRequestPointerLock()
      }
    })

    // Auto-focus canvas on page load
    canvas.focus()
    window.addEventListener('load', () => canvas.focus())

    // Camera-attached lights (like PyMOL/ChimeraX)
    const light1 = new BABYLON.DirectionalLight('dirLight', new BABYLON.Vector3(0, 0, 1), scene)
    light1.intensity = 0.7
    light1.parent = camera

    const light2 = new BABYLON.HemisphericLight('hemiLight', new BABYLON.Vector3(0, 1, 0), scene)
    light2.intensity = 0.4 // Ambient fill light

    engine.runRenderLoop(() => scene.render())
    window.addEventListener('resize', () => {
      engine.setHardwareScalingLevel(1 / window.devicePixelRatio)
      engine.resize()
    })

    // WASD + QE controls (Minecraft-style)
    camera.keysUp.push(87)    // W
    camera.keysDown.push(83)  // S
    camera.keysLeft.push(65)  // A
    camera.keysRight.push(68) // D

    // QE for up/down, JIKL; for mouse look, H for HUD toggle
    const keys = {}
    window.addEventListener('keydown', e => {
      const key = e.key.toLowerCase()
      keys[key] = true

      // Toggle HUD with 'h' key
      if (key === 'h') {
        hudVisible = !hudVisible
        hudEl.style.display = hudVisible ? 'block' : 'none'
        playPauseBtn.style.display = hudVisible ? 'block' : 'none'
        atomHudEl.style.display = hudVisible ? 'block' : 'none'
      }
    })
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false)

    const lookSpeed = 0.01
    scene.registerBeforeRender(() => {
      if (keys['q']) camera.position.y -= 0.5
      if (keys['e']) camera.position.y += 0.5

      // JIKL; for looking around
      if (keys['j']) camera.rotation.y -= lookSpeed  // Look left
      if (keys[';']) camera.rotation.y += lookSpeed  // Look right
      if (keys['i']) camera.rotation.x -= lookSpeed  // Look up
      if (keys['k']) camera.rotation.x += lookSpeed  // Look down
      if (keys['l']) camera.rotation.x -= lookSpeed  // Look up (alternative)

      // Raycast from camera center to detect atom at crosshair
      if (hudVisible && atomSpheres.length > 0) {
        const ray = camera.getForwardRay(1000)
        const hit = scene.pickWithRay(ray)

        if (hit && hit.pickedMesh) {
          // Extract atom index from mesh name (format: "atom123")
          const atomIndex = parseInt(hit.pickedMesh.name.substring(4))
          if (!isNaN(atomIndex) && atomIndex < atoms.length) {
            const atom = atoms[atomIndex]
            atomElementEl.textContent = atom.atomName + ' (' + atom.element + ')'
            atomResidueEl.textContent = atom.resName + ' ' + atom.resNum
          }
        } else {
          atomElementEl.textContent = '-'
          atomResidueEl.textContent = '-'
        }
      }
    })

    // Parse PDB file
    function parsePDB(text) {
      const lines = text.split('\n')
      const parsedAtoms = []
      for (const line of lines) {
        if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
          const element = line.substring(76, 78).trim() || line.substring(12, 14).trim().charAt(0)
          const atomName = line.substring(12, 16).trim()
          const resName = line.substring(17, 20).trim()
          const resNum = line.substring(22, 26).trim()
          const x = parseFloat(line.substring(30, 38))
          const y = parseFloat(line.substring(38, 46))
          const z = parseFloat(line.substring(46, 54))
          parsedAtoms.push({ element, atomName, resName, resNum, x, y, z })
        }
      }
      return parsedAtoms
    }

    // Parse DCD binary file
    function parseDCD(arrayBuffer) {
      try {
        const view = new DataView(arrayBuffer)
        let offset = 0

        // First block: main header
        console.log('Parsing header at offset:', offset, 'bufferSize:', arrayBuffer.byteLength)
        const hdrSize = view.getInt32(offset, true); offset += 4
        console.log('hdrSize:', hdrSize, 'offset:', offset)

        // Read the block content (hdrSize bytes)
        const magic = new TextDecoder('ascii').decode(new Uint8Array(arrayBuffer, offset, 4)); offset += 4
        console.log('magic:', magic, 'offset:', offset)
        const nFrames = view.getInt32(offset, true); offset += 4
        console.log('nFrames:', nFrames, 'offset:', offset)

        // Skip to the end of this block
        offset = 4 + hdrSize  // Jump to end marker position
        console.log('Jumping to end of header block at offset:', offset)
        const hdrEnd = view.getInt32(offset, true); offset += 4  // Should match hdrSize
        console.log('hdrEnd:', hdrEnd, 'should match hdrSize:', hdrSize, 'offset:', offset)

        // Second block: title (skip entire block using titleSize)
        console.log('Reading title at offset:', offset)
        const titleSize = view.getInt32(offset, true); offset += 4
        console.log('titleSize:', titleSize, 'offset:', offset)
        offset += titleSize  // Skip entire title block content
        const titleEnd = view.getInt32(offset, true); offset += 4
        console.log('titleEnd:', titleEnd, 'should match titleSize:', titleSize, 'offset:', offset)

        // Third block: natoms
        const natSize = view.getInt32(offset, true); offset += 4  // Should be 4
        const nAtoms = view.getInt32(offset, true); offset += 4
        const natEnd = view.getInt32(offset, true); offset += 4

        console.log('DCD header:', { magic, nFrames, nAtoms, hdrSize, natSize, offset })

        // Check if DCD has unit cell info (peek at first block size)
        const firstBlockSize = view.getInt32(offset, true)
        const hasUnitCell = firstBlockSize === 48 // 48 bytes = 6 doubles for unit cell
        console.log('First block size:', firstBlockSize, 'hasUnitCell:', hasUnitCell)

        // Read frames - only read frames that actually exist in the buffer
        const parsedFrames = []
        const unitCellBytes = hasUnitCell ? 56 : 0 // 4 (size) + 48 (data) + 4 (size)
        const bytesPerFrame = unitCellBytes + 3 * (8 + nAtoms * 4) // unit cell + 3 coords * (header + data + footer)
        const maxPossibleFrames = Math.floor((arrayBuffer.byteLength - offset) / bytesPerFrame)
        const actualFrames = Math.min(nFrames, maxPossibleFrames)

        console.log('nFrames from header:', nFrames, 'maxPossible:', maxPossibleFrames, 'will read:', actualFrames)

        for (let f = 0; f < actualFrames; f++) {
          // Check if we have enough bytes left for a complete frame
          const remainingBytes = arrayBuffer.byteLength - offset
          if (remainingBytes < bytesPerFrame) {
            console.warn('Incomplete frame', f, '- stopping parse')
            break
          }

          // Skip unit cell data if present
          if (hasUnitCell) {
            const cellBlockSize = view.getInt32(offset, true); offset += 4
            offset += cellBlockSize // Skip the 48 bytes of unit cell data
            const cellBlockEnd = view.getInt32(offset, true); offset += 4
          }

          const coords = { x: [], y: [], z: [] }

          // X coordinates
          const xBlockSize = view.getInt32(offset, true); offset += 4
          if (f === 0) console.log('Frame 0 X block size:', xBlockSize, 'expected:', nAtoms * 4)
          for (let i = 0; i < nAtoms; i++) {
            coords.x.push(view.getFloat32(offset, true))
            offset += 4
          }
          const xBlockEnd = view.getInt32(offset, true); offset += 4
          if (f === 0 && xBlockSize !== xBlockEnd) {
            console.warn('X block size mismatch:', xBlockSize, '!=', xBlockEnd)
          }

          // Y coordinates
          const yBlockSize = view.getInt32(offset, true); offset += 4
          for (let i = 0; i < nAtoms; i++) {
            coords.y.push(view.getFloat32(offset, true))
            offset += 4
          }
          const yBlockEnd = view.getInt32(offset, true); offset += 4

          // Z coordinates
          const zBlockSize = view.getInt32(offset, true); offset += 4
          for (let i = 0; i < nAtoms; i++) {
            coords.z.push(view.getFloat32(offset, true))
            offset += 4
          }
          const zBlockEnd = view.getInt32(offset, true); offset += 4

          parsedFrames.push(coords)
        }

        console.log('Parsed frames:', parsedFrames.length)
        return parsedFrames
      } catch (err) {
        console.error('DCD parse error:', err)
        return []
      }
    }

    // Create atom spheres
    function createAtoms() {
      atomSpheres.forEach(s => s.dispose())
      atomSpheres = []

      // Calculate center of mass
      let cx = 0, cy = 0, cz = 0
      for (const atom of atoms) {
        cx += atom.x
        cy += atom.y
        cz += atom.z
      }
      cx /= atoms.length
      cy /= atoms.length
      cz /= atoms.length

      console.log('Molecule center:', cx, cy, cz)

      for (let i = 0; i < atoms.length; i++) {
        const atom = atoms[i]
        const element = atom.element
        const radius = CPK_RADII[element] || 0.7
        const color = CPK_COLORS[element] || [0.8, 0.8, 0.8]

        const sphere = BABYLON.MeshBuilder.CreateSphere(`atom${i}`, { diameter: radius * 2, segments: 12 }, scene)
        const material = new BABYLON.StandardMaterial(`mat${i}`, scene)
        material.diffuseColor = new BABYLON.Color3(...color)
        material.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3)
        sphere.material = material

        sphere.position.x = atom.x
        sphere.position.y = atom.y
        sphere.position.z = atom.z

        atomSpheres.push(sphere)
      }

      // Position camera to face molecule - calculate bounding box for better distance
      let minX = Infinity, maxX = -Infinity
      let minY = Infinity, maxY = -Infinity
      let minZ = Infinity, maxZ = -Infinity
      for (const atom of atoms) {
        minX = Math.min(minX, atom.x); maxX = Math.max(maxX, atom.x)
        minY = Math.min(minY, atom.y); maxY = Math.max(maxY, atom.y)
        minZ = Math.min(minZ, atom.z); maxZ = Math.max(maxZ, atom.z)
      }
      const sizeX = maxX - minX
      const sizeY = maxY - minY
      const sizeZ = maxZ - minZ
      const maxDim = Math.max(sizeX, sizeY, sizeZ)
      const distance = maxDim * 1.5 // Position camera 1.5x the molecule size away

      camera.position = new BABYLON.Vector3(cx, cy, cz - distance)
      camera.setTarget(new BABYLON.Vector3(cx, cy, cz))

      atomCountEl.textContent = atoms.length
    }

    // Update atom positions for current frame
    function updateFrame() {
      if (frames.length === 0) {
        console.log('updateFrame: no frames')
        return
      }

      const frame = frames[currentFrame]
      if (!frame) {
        console.log('updateFrame: frame', currentFrame, 'is undefined')
        return
      }

      for (let i = 0; i < atomSpheres.length && i < frame.x.length; i++) {
        atomSpheres[i].position.x = frame.x[i]
        atomSpheres[i].position.y = frame.y[i]
        atomSpheres[i].position.z = frame.z[i]
      }

      frameInfoEl.textContent = `${currentFrame + 1}/${frames.length}`
    }

    // Animation loop
    let animateStarted = false
    let frameCounter = 0
    let lastFrameTime = 0
    const frameInterval = 50 // 20 fps (50ms between frames)

    function animate(timestamp) {
      if (!animateStarted) {
        console.log('Animation loop started, playing:', playing, 'frames:', frames.length)
        animateStarted = true
        lastFrameTime = timestamp
      }

      // Update at ~20fps regardless of render rate
      if (timestamp - lastFrameTime >= frameInterval) {
        if (playing && frames.length > 0) {
          currentFrame = (currentFrame + 1) % frames.length
          updateFrame()
          frameCounter++
          if (frameCounter % 100 === 0) {
            console.log('Animation frame:', currentFrame, 'counter:', frameCounter)
          }
        }
        lastFrameTime = timestamp
      }

      requestAnimationFrame(animate)
    }

    async function getConfig() {
      const res = await fetch('/api/config')
      if (!res.ok) throw new Error('Config fetch failed')
      return await res.json()
    }

    async function headSize(url) {
      const res = await fetch(url, { method: 'HEAD' })
      if (!res.ok) return 0
      const len = res.headers.get('content-length')
      return len ? Number(len) : 0
    }

    async function loadAll() {
      const cfg = await getConfig()
      const base = cfg.mdsrvUrl.replace(/\/$/, '')
      const pdbUrl = base + '/data/' + cfg.topology
      const dcdUrl = base + '/data/' + cfg.trajectory

      statusEl.textContent = 'LOADING STRUCTURE...'
      const pdbRes = await fetch(pdbUrl)
      const pdbText = await pdbRes.text()
      atoms = parsePDB(pdbText)
      console.log('Loaded atoms:', atoms.length)

      createAtoms()

      statusEl.textContent = 'LOADING TRAJECTORY...'
      const dcdRes = await fetch(dcdUrl)
      const dcdBuffer = await dcdRes.arrayBuffer()
      console.log('DCD buffer size:', dcdBuffer.byteLength)
      frames = parseDCD(dcdBuffer)
      console.log('Loaded frames:', frames.length)

      // Validate frame data matches atom count
      if (frames.length > 0 && frames[0].x.length !== atoms.length) {
        console.error('Atom count mismatch! PDB:', atoms.length, 'DCD frame:', frames[0].x.length)
        statusEl.textContent = `error: atom count mismatch (PDB: ${atoms.length}, DCD: ${frames[0].x.length})`
        return
      }

      // Check if frames differ
      if (frames.length > 1) {
        console.log('Frame 0, atom 0:', frames[0].x[0], frames[0].y[0], frames[0].z[0])
        console.log('Frame 1, atom 0:', frames[1].x[0], frames[1].y[0], frames[1].z[0])
        if (frames.length > 100) {
          console.log('Frame 100, atom 0:', frames[100].x[0], frames[100].y[0], frames[100].z[0])
        }
      }

      if (frames.length > 0) {
        currentFrame = 0
        updateFrame()
      }

      currentBytes = await headSize(dcdUrl)
      statusEl.textContent = 'READY'
      requestAnimationFrame(animate)

      // Auto-start polling
      pollTimer = setInterval(checkForNewFrames, pollIntervalSeconds * 1000)
    }

    async function checkForNewFrames() {
      const cfg = await getConfig()
      const base = cfg.mdsrvUrl.replace(/\/$/, '')
      const dcdUrl = base + '/data/' + cfg.trajectory
      const size = await headSize(dcdUrl)

      if (size > currentBytes) {
        const oldFrameCount = frames.length
        currentBytes = size
        statusEl.textContent = 'LOADING NEW FRAMES...'

        // Retry logic for partial DCD reads
        let retries = 3
        let newFrames = []
        while (retries > 0) {
          try {
            const dcdRes = await fetch(dcdUrl + '?t=' + Date.now())
            const dcdBuffer = await dcdRes.arrayBuffer()
            newFrames = parseDCD(dcdBuffer)
            if (newFrames.length > 0) break
          } catch (err) {
            console.warn('DCD parse error, retrying...', err)
            await new Promise(r => setTimeout(r, 500)) // Wait 500ms before retry
          }
          retries--
        }

        if (newFrames.length > 0) {
          frames = newFrames
          const newFrameCount = frames.length - oldFrameCount
          if (newFrameCount > 0) {
            statusEl.textContent = `+${newFrameCount} FRAMES`
            setTimeout(() => statusEl.textContent = 'READY', 2000)
          } else {
            statusEl.textContent = 'READY'
          }
        } else {
          statusEl.textContent = 'PARSE ERROR'
        }
      }
    }

    playPauseBtn.onclick = () => {
      playing = !playing
      playPauseBtn.textContent = playing ? '⏸ PAUSE' : '▶ PLAY'
    }

    loadAll().catch(err => {
      console.error(err)
      statusEl.textContent = 'ERROR: ' + err.message
    })
  </script>
</body>
</html>